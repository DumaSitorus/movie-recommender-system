# -*- coding: utf-8 -*-
"""Model Sistem Rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-hxGgs4vwj6ecJb-LmAq1gJv3LrgwQtw

# **Sistem Rekomendasi Film - Netflix**

- **Nama:** Duma Mora Arta Sitorus
- **Email:** dumamora5@gmail.com
- **ID Dicoding:** duma_mora

## Import Library
"""

import pandas as pd
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import EarlyStopping
import matplotlib.pyplot as plt

"""## Data Understanding

Dataset yang digunakan pada proyek ini diperoleh dari public reposiitory Kaggle yang dapat diakses melalui tautan berikut: [movie recommender dataset](https://www.kaggle.com/datasets/gargmanas/movierecommenderdataset)

Dataset movie recommender terdiri dari atas 2 file terpisah yaitu movie dan rating.
"""

movie = pd.read_csv("https://raw.githubusercontent.com/DumaSitorus/movie-recommender-system/refs/heads/main/dataset/movies.csv")
rating = pd.read_csv("https://raw.githubusercontent.com/DumaSitorus/movie-recommender-system/refs/heads/main/dataset/ratings.csv")

"""## Exploratory Data Analysis

Tahap Exploratory Data Analysis bertujuan untuk melakukan analisis dan eksplorasi terhadap variabel pada data.

### Movie
"""

movie.info()

movie.sample(10)

print('Banyak genres: ', len(movie.genres.unique()))
print('Tipe masakan: ', movie.genres.unique())

"""**Hasil analisis data movie:**

Data `movie` terdiri dari tiga buah kolom yaitu:

1. `movieId`
  - kolom ini berisikan nomor identifikasi unik yang membedakan setiap data movie.
  - kolom `movieId` bertipe integer dan tidak memiliki *missing value*

2. `title`
  - kolom ini berisikan data judul film yang tersusun oleh `judul + (tahun tayang)`
  -  kolom `title` bertipe object dan tidak memiliki *missing value*

3. `genres`
  - kolom ini berisikan data berupa genre atau jenis film atau movie.
  -  kolom `genres` bertipe object dan tidak memiliki *missing value*
  - terdapat 951 data genre unik pada data movie dengan berbagai kombinasi dari 20 genre film yang ada. yaitu `action`, `adventure`, `animation`, `children`, `comedy`, `crime`, `documentary`, `drama`, `fantasy`, `film`, `horror`, `imax`, `musical`, `mystery`, `noir`, `romance`, `Sci-Fi`, `thriller`, `war`, `western`
  - terdapat film dengan genre yang tidak memiliki nilai tetapi diisi dengan teks `(no genres listed)`

---
Berdasarkan hasil analisis tersebut, diperlukan perbaikan untuk data movie sebagai berikut:
1. Data pada kolom `title` perlu dipisahkan antara judul dengan tahun tayang agar tidak memberikan representasi yang berbeda pada dua atau lebih film yang sama dengan tahun tayang yang berbeda ketika diterapkan TF-IDF.

2. Perlu perbaikan pada salah satu genre yaitu Sci-Fi yang merujuk pada genre Science Fiction. Penggunaan tanda hubunga (karakter '-') dapat memberikan representasi yang berbeda pada dua kata yaitu Sci dan Fi pada saat penggunaan TF-IDF yang menganggap katakter '-' sebagai pemisah antar kata.

3. Diperlukan penanganan pada data movie dengan genre yang kosong atau berikan `(no genres listed)`. Solusi yang dapat diberikan dapat berupa drop data jika data tidak terlalu banyak.

### Rating
"""

rating.info()

rating.sample(10)

rating.describe()

print("Jumlah user yang memberi rating pada movie: ", len(rating.userId.unique()))
print("Jumlah movie yang diberi rating: ", len(rating.movieId.unique()))
print("Jumlah keseluruhan data rating: ", len(rating))

"""**Hasil analisis data rating:**

Data `rating` terdiri dari empat buah kolom yaitu:

1. `userId`
  - kolom ini berisikan nomor identifikasi pengguna yang memberikan rating pada film
  - kolom `userId` bertipe integer dan tidak memiliki *missing value*
  - terdapat total 610 pengguna yang memberikan rating terhadap film

2. `movieId`
  - kolom ini berisikan nomor identifikasi film yang telah diberikan rating oleh pengguna
  -  kolom `movieId` bertipe integer dan tidak memiliki *missing value*
  - terdapat 9724 film yang telah diberikan rating oleh pengguna

3. `rating`
  - kolom ini berisikan data rating pengguna terhadap film
  -  kolom `rating` bertipe float dan tidak memiliki *missing value*
  - kolom `rating` memiliki nilai dari 0.5 hingga 5. sehingga terdapat 10 nilai unik untuk rating.
  - total keseluruhan aktivitas rate film yang tercatat pada data berjumlah 100836

4. `timestamp`
  - kolom ini berisikan data berupa timestamp atau waktu ketika data dimasukkan kedalam basis data.
  -  kolom `timestamp` bertipe integer dan tidak memiliki *missing value*

---
Berdasarkan hasil analisis tersebut, tidak terdapat permasalahan dalam dataset tersebut sehingga tidak perlu dilakukan penanganan apapun pada tahap preprocessing.

## Data Preprocessing

Ini merupakan tahap persiapan data sebelum data digunakan untuk proses selanjutnya. Pada tahap ini, dilakukan dengan penggabungan beberapa file sehingga menjadi satu kesatuan file yang utuh dan siap digunakan dalam tahap pemodelan.
"""

df = rating.merge(movie, on='movieId')

df.sample(10)

df.isnull().sum()

print("jumlah data duplikat:", df.duplicated().sum())

len(df[df['genres'] == '(no genres listed)'])

"""**Catatan untuk proses Preprocessing:**

Tahap data preprocessing dilakukan dengan menggabungkan data movie dan rating kedalam dataframe. Berikut adalah rincian langkah yang telah dilakukan pada tahapan ini:

1. Menggabungkan tabel rating dengan tabel movie berdasarkan movieId ke dalam sebuah dataframe bernama `df`.
2. Melakukan pengecekan apakah terdapat missing value pada data setelah dilakukan merging. Hasil yang diberikan yaitu tidak ada missing value, sehingga tidak perlu dilakukan penanganan missing value.
3. Mengecekan apakah terdapat dupliaksi pada data setelah dilakukan merging. Hasil yang diberikan yaitu tidak terdapat duplikasi, sehingga tidak perlu dilakukan penanganan duplicated data.

4. Mengecek apakah terdapat invalid value pada kolom genre. Dan, Ya terdapat genre yang bernilai (no genres listed). hal ini perlu penanganan lebih lanjut untuk menghasilkan data yang bermakna.

## Data Preparation

Pada tahap ini, dilakukan persiapan data dan melakukan beberapa teknik seperti mengatasi missing value dan solusi lainnya untuk menghasilkan data yang berkualitas.

**Catatan untuk proses Preparation:**

Tahapan preparation bertujuan untuk mempersiapkan dataset agar bersih dan siap untuk masuk ke tahap pengembangan model sistem rekomendasi. Adapun langkah yang dilakukan pada tahapan ini antara lain:

1. Menangani (data no genres listed) pada kolom genres. Solusi penanganan yang diberikan yaitu drop data, jumlah data dengan value (data no genres listed) hanya 47 buah, yang mana ini terbilang sedikit dari keseluruhan data yang berjumlah 100836.
2. Memisahkan title dan tahun tayang movie menggunakan regular expression. Title akan tetap berada di kolom title sedangkan tahun tayang movie akan dipindahkan ke kolom year.
3. Menangani karakter '|' dan genre 'Sci-Fi' pada kolom genres. Penanganan ini dilakukan dengan menggunakan regular ekspression/ karakter '|' akan dihapus dan diganti dengan karakter space (' ') dan genre dengan value 'Sci-Fi' diganti dengan 'SciFi'.

### Menangani (data no genres listed) pada kolom genres
"""

df = df[df['genres'] != '(no genres listed)']
print("no genres listed movie:", len(df[df['genres'] == '(no genres listed)']))

df['genres'] = df['genres'].str.replace('|', ' ', regex=False)
df.sample(10)

df['genres'] = df['genres'].str.replace('Sci-Fi', 'SciFi', regex=False)

scifi_movies = df[df['genres'].str.contains('SciFi')]
scifi_movies.sample(10)

"""### Memisahkan title dan tahun tayang movie"""

movie['year'] =  movie['title'].str.extract(r'\((\d{4})\)')
movie['title'] =  movie['title'].str.replace(r'\((\d{4})\)', '', regex=True).str.strip()

movie.sample(10)

"""### Menanganai karakter '|' dan genre Sci-Fi pada kolom genres"""

movie['genres'] = movie['genres'].str.replace('|', ' ', regex=False)
movie['genres'] = movie['genres'].str.replace('Sci-Fi', 'SciFi', regex=False)

scifi_movie = movie[movie['genres'].str.contains('SciFi')]
scifi_movie.sample(10)

len(movie[movie['genres'] == '(no genres listed)'])

movie = movie[movie['genres'] != '(no genres listed)']
print("no genres listed movie:", len(movie[movie['genres'] == '(no genres listed)']))

"""### Data Preparation untuk pengembangan sistem rekomendasi dengan pendekatan content based filtering

#### Menyiapakan data
"""

# data movie yang telah melewati tahapan preprocessing
data = movie
data.sample(5)

"""Data yang digunakan merupakan data movie yang telah dibersihkan pada tahap preprocessing. Penggunaan data ini karena kita ingin mempertimbangkan rekomendasi film berdasarkan kemiripan genres antar film.

#### TF-IDF Vectorizer
"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genres
tf.fit(data['genres'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

tfidf_matrix = tf.fit_transform(data['genres'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan genre movie
# Baris diisi dengan judul movie

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=data.title
).sample(20, axis=1).sample(10, axis=0)

"""Output diatas merupakan hasil matriks tf-idf yang dihitung sebelumnya. baris mewakili item atau film sedangkan kolom berisikan kata-kata unik dari genres. Nilai yang terdapat pada baris dan kolom tertentu merupakan representasi seberapa penting genre dalam sebuah film.

Jadi intinya hasil perhitungan TF-IDF memberikan representasi numerik yang mengindikasikan pentingnya kata-kata dalam judul atau genre secara relatif.

### Data Preparation untuk pengembangan sistem rekomendasi dengan pendekatan collaborative filtering

#### Data Preparation: Maping Id, Pengacakan Dataset, Normalisasi Rating
"""

df

# Mengubah userId menjadi list tanpa nilai yang sama
user_ids = df['userId'].unique().tolist()
print('list userId: ', user_ids)

# Melakukan encoding userId
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded userId : ', user_to_user_encoded)

# Melakukan proses encoding angka ke ke userId
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke userId: ', user_encoded_to_user)

# Mengubah movieId menjadi list tanpa nilai yang sama
movie_ids = df['movieId'].unique().tolist()

# Melakukan proses encoding movieId
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}

# Melakukan proses encoding angka ke movieId
movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}
print('encoded angka ke userId: ', user_encoded_to_user)

# Mapping userID ke dataframe user
df['user'] = df['userId'].map(user_to_user_encoded)

# Mapping placeID ke dataframe resto
df['movie'] = df['movieId'].map(movie_to_movie_encoded)

# Mendapatkan jumlah user
num_users = len(user_to_user_encoded)
print(num_users)

# Mendapatkan jumlah movie
num_movie = len(movie_encoded_to_movie)
print(num_movie)

# Mengubah rating menjadi nilai float
df['rating'] = df['rating'].values.astype(np.float32)

# Nilai minimum rating
min_rating = min(df['rating'])

# Nilai maksimal rating
max_rating = max(df['rating'])

print('Number of User: {}, Number of movie: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_movie, min_rating, max_rating
))

"""Data preparation ini berguna untuk melakukan encoding pada movieId dan userId. setelah itu, hasil encoding akan disimpan di dalam kolom movie dan user.

#### Data Splitting
"""

# Mengacak dataset
df = df.sample(frac=1, random_state=42)
df

# Membuat variabel x untuk mencocokkan data user dan movie menjadi satu value
x = df[['user', 'movie']].values

# Membuat variabel y untuk membuat rating dari hasil
y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

"""Data splitting berguna untuk membagi data menjadi data train dan data test. keseluruhan data akan dibagi menjadi X dan y. X berisi data user dan movie sedangkan y berisi berisi data rating pengguna terhadap movie. Pembagian data train dan test menggunakan rasio 80:20.

## Model Development

### Content Based Filtering

Pada tahap inilah dilakukan pengembangkan sistem rekomendasi dengan teknik content based filtering. Teknik content based filtering akan merekomendasikan item yang mirip dengan item yang disukai pengguna di masa lalu. Pada tahap ini.Pada tahapan ini akan menggunakan teknik menemukan representasi fitur penting dari setiap kategori movie dengan tfidf vectorizer dan menghitung tingkat kesamaan dengan cosine similarity. Setelah itu, dilakukan pembuatan sejumlah rekomendasi movie berdasarkan kesamaan yang telah dihitung sebelumnya.

#### Cosine Similarity
"""

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa title movie
cosine_sim_df = pd.DataFrame(cosine_sim, index=data['title'], columns=data['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap movie
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Nilai dari matrix TF-IDF yang telah diperoleh sebelumnya dapat digunakan untuk menghitung Cosine Similarity. Cosine Similarity menghitung seberapa mirip dua vektor, misalnya, vektor TF-IDF dari dua film berdasarkan sudutnya. Vektor dengan nilai TF-IDF yang lebih besar pada kata-kata yang relevan akan menghasilkan nilai cosine similarity yang lebih tinggi, dimana ini berarti mereka lebih mirip.

Sehingga dari perhitungan cosine similarity diperoleh hasil berupa hasil pengukuran kemiripan antara setiap film. Nilai ini yang dipertimabngkan oleh sistem rekomendasi untuk menentukan film yang mirip satu-sama lain.

#### Mendapatkan Rekomendasi
"""

def movie_recommendations(movie_title, similarity_data=cosine_sim_df, items=data[['title', 'genres']], k=5):
    """
    Rekomendasi movie berdasarkan kemiripan dataframe

    Parameter:
    ---
    movie_title : tipe data string (str)
                Judul movie (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan movie sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,movie_title].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop movie_title agar judul movie yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(movie_title, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

data[data.title.eq('Kung Fu Panda')]

movie_recommendations('Kung Fu Panda')

"""Yeay, hasil rekomendasi film telah berhasil diperoleh.

---

Hasil tersebut diperoleh dengan terlebih dahulu membuat fungsi movie_recommendations yang akan mengembalikan top-N recomendation yang mirip dengan judul movie yang diinputkan. Tidak lupa dilakukan Drop movie title yang diinputkan pada fungsi agar judul movie yang dicari tidak muncul dalam daftar rekomendasi

### Collaborative Filtering

Pada pendekatan ini, akan menghasilkan mode yang mampu memberikan rekomendasi film atau movie berdasarkan rating yang pengguna sebelumnya. Melalui data rating pengguna akan diidentifikasi sekumpulan film yang mirip dan belum pernah berinteraksi sebelumnya oleh pengguna untuk direkomendasikan.

#### Modelling
"""

class RecommenderNet(tf.keras.Model):

  # Insialisasi fungsi
  def __init__(self, num_users, num_movie, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movie = num_movie
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.movie_embedding = layers.Embedding( # layer embeddings movie
        num_movie,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = layers.Embedding(num_movie, 1) # layer embedding movie bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    movie_vector = self.movie_embedding(inputs[:, 1]) # memanggil layer embedding 3
    movie_bias = self.movie_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_movie = tf.tensordot(user_vector, movie_vector, 2)

    x = dot_user_movie + user_bias + movie_bias

    return tf.nn.sigmoid(x) # activation sigmoid

model = RecommenderNet(num_users, num_movie, 50) # inisialisasi model

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model ini menggunakan Binary Crossentropy untuk menghitung loss function, Adam (Adaptive Moment Estimation) sebagai optimizer, dan root mean squared error (RMSE) sebagai metrics evaluation."""

# Memulai training
history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 32,
    epochs = 15,
    validation_data = (x_val, y_val),
)

"""#### Evaluasi dengan Visualisasi Metrik

Untuk melihat visualisasi proses training, mari kita plot metrik evaluasi dengan matplotlib.
"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""Berdasarkan hasil plot tersebut, terlihat bahwa nilai Root Mean Squere Error terus menurun seiring bertambahnya epoch dengan nilai error  akhir sebesar 0.1867 untuk pelatihan dan 0.1994 untuk test.

#### Mendapatkan rekomendasi Movie

Pada tahapan ini akan dilakukan percobaan untuk memperoleh hasil rekomendasi untuk sampel user. Hasil rekomendasi akan memberikan judul film yang pernah dirating dengan nilai tinggi oleh user tersebut, kemudian menampilkan rekomendasi film berdasarkan preferensi dan rating para pengguna.
"""

# Mengonversi data series ‘placeID’ menjadi dalam bentuk list
movie_id = movie['movieId'].tolist()

# Mengonversi data series ‘Name’ menjadi dalam bentuk list
movie_title = movie['title'].tolist()

# Mengonversi data series ‘Rcuisine’ menjadi dalam bentuk list
movie_genres = movie['genres'].tolist()

print(len(movie_id))
print(len(movie_title))
print(len(movie_genres))

movie_df = pd.DataFrame({
    'id': movie_id,
    'movie_title': movie_title,
    'genres': movie_genres
})

movie_df.sample(10)

# df = pd.read_csv('rating_final.csv')
df = pd.read_csv("https://raw.githubusercontent.com/DumaSitorus/movie-recommender-system/refs/heads/main/dataset/ratings.csv")

# Mengambil sample user
user_id = df.userId.sample(1).iloc[0]
movie_watched_by_user = df[df.userId == user_id]

# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html
movie_not_watched = movie_df[~movie_df['id'].isin(movie_watched_by_user.movieId.values)]['id']
movie_not_watched = list(
    set(movie_not_watched)
    .intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_watched = [[movie_to_movie_encoded.get(x)] for x in movie_not_watched]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoder]] * len(movie_not_watched), movie_not_watched)
)

ratings = model.predict(user_movie_array).flatten()

top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_to_movie_encoded.get(movie_not_watched[x][0]) for x in top_ratings_indices
]

print('Showing recommendations for users: {}'.format(user_id))
print('===' * 9)
print('\n')
print('Movie with high ratings from user')
print('----' * 8)

top_movie_user = (
    movie_watched_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .movieId.values
)

movie_df_rows = movie_df[movie_df['id'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.movie_title, ':', row.genres)

print('\n')
print('----' * 8)
print('Top-n movie recommendation')
print('----' * 8)

recommended_movie = movie_df[movie_df['id'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.movie_title, ':', row.genres)

"""Dari hasil tersebut, terlihat bahwa model telah berhasil memberikan daftar rekomendasi beberapa film yang belum pernah ditonton oleh pengguna berdasarkan rating pengguna terhadap film sebelumnya. Pada hasil yang diberikan tidak menampilkan Top-10 melainkan hanya 3 saja, ini kemungkinan terjadi karena film yang yang direkomendasikan telah ditonton sebelumnya oleh pengguna tersebut.

## Consclusion
Pada proyek pengembangan sistem rekomendasi film ini, saya telah berhasil membuat sistem rekomendasi dengan pendekatan Content based Filtering dan Collaborative Filtering. Sistem rekomendasi dengan pendekatan Content based Filtering telah berhasil memberikan top-5 rekomendasi film yang mirip berdasarkan judul dan genre film tersebut.

Kemudian, untuk dengan penekatan Collaborative Filtering telah berhasil melatih model yang mampu memberikan rekomendasi film berdasarkan preferensi pengguna seperti rating terhadap film.

Konsep pada proyek ini dapat diimplementasikan dengan menyesuaikan data mengingat industri film terus meproduksi film setiap waktu sehingga perlu penyesuaian dataset.
"""